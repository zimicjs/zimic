name: Zimic Release Comments
description: Comment on related issues and pull requests after a Zimic release and close the milestone.

inputs:
  type:
    description: The type of the release (package or documentation)
    required: true
  ref-name:
    description: The Git reference name to create release comments for
    required: true
  project-name:
    description: The project name to create release comments for
    required: true

runs:
  using: composite
  steps:
    - name: Create release comments and close milestone
      uses: actions/github-script@v7
      with:
        script: |
          const DELAY_BETWEEN_COMMENTS = 1000;
          const PER_PAGE = 100;

          const releaseType = '${{ inputs.type }}';
          const projectName = '${{ inputs.project-name }}';
          const tag = '${{ inputs.ref-name }}';
          const version = tag.replace(/^@?[^@]*@|^v/, '');

          const isStable = !version.includes('-');
          const isCanary = version.includes('-canary.');
          const isReleaseCandidate = version.includes('-rc.');

          const githubOwner = 'zimicjs';
          const githubRepository = 'zimic';

          const commentBody = [
            releaseType === 'package' && `### Released in [${tag}](https://github.com/${githubOwner}/${githubRepository}/releases/tag/${tag}) :tada:\n`,
            releaseType === 'documentation' && isStable && '### Released to [**zimic.dev**](https://zimic.dev) :tada:\n',
            releaseType === 'documentation' && isCanary && '### Released to [**canary.zimic.dev**](https://canary.zimic.dev) :tada:\n',
            releaseType === 'documentation' && isReleaseCandidate && '### Released to [**rc.zimic.dev**](https://rc.zimic.dev) :tada:\n',
            `- :pushpin: [**Release notes**](https://github.com/${githubOwner}/${githubRepository}/releases/tag/${tag})`,
            releaseType === 'package' && `- :package: [**NPM package**](https://www.npmjs.com/package/${projectName}/v/${version})`,
          ]
            .filter(Boolean)
            .join('\n');

          function waitForDelay(milliseconds) {
            return new Promise((resolve) => setTimeout(resolve, milliseconds));
          }

          function extractPullRequestNumbersFromText(text) {
            const pullRequestNumbers = new Set();

            if (!text) {
              return pullRequestNumbers;
            }

            const matches = text.matchAll(
              new RegExp(
                `https:\\/\\/github\\.com\\/${githubOwner}\\/${githubRepository}\\/pull\\/(?<pullRequestNumber>\\d+)`,
                'gi',
              ),
            );

            for (const match of matches) {
              const pullRequestNumber = Number(match.groups.pullRequestNumber);
              pullRequestNumbers.add(pullRequestNumber);
            }

            return pullRequestNumbers;
          }

          function extractLinkedIssueNumbersFromText(text) {
            const issueNumbers = new Set();

            if (!text) {
              return issueNumbers;
            }

            const linkKeywordPatterns = [
              'close',
              'closes',
              'closed',
              'fix',
              'fixes',
              'fixed',
              'resolve',
              'resolves',
              'resolved',
              'part',
              'part of',
            ];

            const issueNumberPatterns = [
              `https:\\/\\/github\\.com\\/${githubOwner}\\/${githubRepository}\\/issues\\/(?<issueNumberFromURL>\\d+)`,
              `${githubOwner}\\/${githubRepository}#(?<issueNumberFromPath>\\d+)`,
              '#(?<issueNumberFromHash>\\d+)',
            ];

            const matches = text.matchAll(
              new RegExp(
                `(?:${linkKeywordPatterns.join('|')})\\b[\\s\\n]*:?[\\s\\n]*(?:${issueNumberPatterns.join('|')})`,
                'gi',
              ),
            );

            for (const match of matches) {
              const issueNumber = Number(
                match.groups.issueNumberFromURL ||
                  match.groups.issueNumberFromPath ||
                  match.groups.issueNumberFromHash,
              );
              issueNumbers.add(issueNumber);
            }

            return issueNumbers;
          }

          let milestone = undefined;

          for (let page = 1; milestone === undefined; page++) {
            try {
              console.log(`Fetching milestone ${tag}... (page ${page})`);

              const milestones = await github.rest.issues.listMilestones({
                owner: githubOwner,
                repo: githubRepository,
                state: 'open',
                page,
                per_page: PER_PAGE,
              });

              milestone = milestones.data.find((milestone) => milestone.title === tag);

              if (milestones.data.length < PER_PAGE) {
                break;
              }
            } catch (error) {
              console.error(`Could not fetch milestone ${tag}.`, error);
              break;
            }
          }

          if (milestone) {
            console.log(`Milestone ${tag} found.`);
          } else {
            console.warn(`Milestone ${tag} not found.`);
          }

          const issueNumbersToCommentOn = new Set();

          if (milestone) {
            for (let page = 1; ; page++) {
              console.log(`Fetching issues and pull requests with milestone ${tag}... (page ${page})`);

              const issues = await github.rest.issues.listForRepo({
                owner: githubOwner,
                repo: githubRepository,
                milestone: milestone.number,
                state: 'all',
                page,
                per_page: PER_PAGE,
              });

              for (const issue of issues.data) {
                console.log(`Found issue or pull request #${issue.number} with milestone ${tag}.`);
                issueNumbersToCommentOn.add(issue.number);
              }

              if (issues.data.length < PER_PAGE) {
                break;
              }
            }
          }

          const pullRequestNumbersMentionedInRelease = new Set();

          try {
            console.log(`Fetching release ${tag}...`);

            const release = await github.rest.repos.getReleaseByTag({
              owner: githubOwner,
              repo: githubRepository,
              tag,
            });

            console.log(`Fetched release ${tag}.`);

            const releaseDescription = release.data.body ?? '';

            for (const pullRequestNumber of extractPullRequestNumbersFromText(releaseDescription)) {
              console.log(`Found pull request #${pullRequestNumber} mentioned in release ${tag}.`);
              pullRequestNumbersMentionedInRelease.add(pullRequestNumber);
              issueNumbersToCommentOn.add(pullRequestNumber);
            }
          } catch (error) {
            console.error(`Release ${tag} not accessible.`, error);
          }

          for (const pullRequestNumber of pullRequestNumbersMentionedInRelease) {
            try {
              console.log(`Fetching pull request #${pullRequestNumber}...`);

              const pullRequest = await github.rest.pulls.get({
                owner: githubOwner,
                repo: githubRepository,
                pull_number: pullRequestNumber,
              });

              console.log(`Fetched pull request #${pullRequestNumber}.`);

              const pullRequestDescription = pullRequest.data.body ?? '';

              for (const issueNumber of extractLinkedIssueNumbersFromText(pullRequestDescription)) {
                console.log(`Found linked issue #${issueNumber} in pull request #${pullRequestNumber}.`);
                issueNumbersToCommentOn.add(issueNumber);
              }
            } catch (error) {
              console.error(`Could not fetch pull request #${pullRequestNumber}.`, error);
            }
          }

          if (issueNumbersToCommentOn.size === 0) {
            console.log('No issues or pull requests found to comment on.');
          } else {
            console.log(
              `Creating release comments on ${issueNumbersToCommentOn.size} item${
                issueNumbersToCommentOn.size === 1 ? '' : 's'
              }...`
            );
          }

          for (const issueNumber of issueNumbersToCommentOn) {
            console.log(`Commenting on #${issueNumber}...`);

            try {
              await github.rest.issues.createComment({
                owner: githubOwner,
                repo: githubRepository,
                issue_number: issueNumber,
                body: commentBody,
              });

              console.log(`Commented on #${issueNumber}.`);
            } catch (error) {
              console.error(`Could not comment on #${issueNumber}.`, error);
            }

            await waitForDelay(DELAY_BETWEEN_COMMENTS);
          }

          if (milestone) {
            console.log(`Closing milestone ${tag}...`);

            await github.rest.issues.updateMilestone({
              owner: githubOwner,
              repo: githubRepository,
              milestone_number: milestone.number,
              state: 'closed',
            });

            console.log(`Milestone ${tag} closed.`);
          }
