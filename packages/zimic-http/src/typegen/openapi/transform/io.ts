import createCachedDynamicImport from '@zimic/utils/import/createCachedDynamicImport';
import fs from 'fs';
import type { SchemaObject } from 'openapi-typescript';
import path from 'path';
import ts from 'typescript';

import { createBlobType, createNullType } from '../utils/types';

const importOpenapiTypeScript = createCachedDynamicImport(() => import('openapi-typescript'));

function transformSchemaObject(schemaObject: SchemaObject) {
  if (schemaObject.format === 'binary') {
    const blobType = createBlobType();

    if (schemaObject.nullable) {
      const nullType = createNullType();
      return ts.factory.createUnionTypeNode([blobType, nullType]);
    }

    return blobType;
  }
}

function convertFilePathOrURLToURL(filePathOrURL: string) {
  try {
    return new URL(filePathOrURL);
  } catch {
    return new URL(`file://${path.resolve(filePathOrURL)}`);
  }
}

export async function importTypesFromOpenAPI(filePathOrURL: string) {
  const schemaURL = convertFilePathOrURLToURL(filePathOrURL);

  const { default: generateTypesFromOpenAPI } = await importOpenapiTypeScript();

  const rawNodes = await generateTypesFromOpenAPI(schemaURL, {
    alphabetize: false,
    additionalProperties: false,
    excludeDeprecated: false,
    propertiesRequiredByDefault: false,
    defaultNonNullable: true,
    pathParamsAsTypes: false,
    emptyObjectsUnknown: true,
    exportType: false,
    arrayLength: false,
    immutable: false,
    enumValues: false,
    enum: false,
    silent: true,
    transform: transformSchemaObject,
  });

  return rawNodes;
}

export async function convertTypesToString(nodes: ts.Node[], options: { includeComments: boolean }) {
  const { astToString: convertTypeASTToString } = await importOpenapiTypeScript();

  const typegenResult = convertTypeASTToString(nodes, {
    formatOptions: { removeComments: !options.includeComments },
  });

  return typegenResult;
}

export function formatTypegenResultToOutput(typegenResult: string) {
  const formattedResult = typegenResult
    .replace(/^export (\w+)/gm, '\nexport $1')
    .replace(/^( {4})+/gm, (match) => match.replace(/ {4}/g, '  '));

  return [
    '// Auto-generated by @zimic/http.',
    '// NOTE: Do not manually edit this file. Changes will be overridden.\n',
    formattedResult,
  ].join('\n');
}

export async function writeTypegenResultToStandardOutput(typegenResult: string) {
  await new Promise((resolve) => {
    process.stdout.write(typegenResult, 'utf-8', resolve);
  });
}

export async function writeTypegenResultToFile(outputFilePath: string, formattedResult: string) {
  const outputDirectory = path.dirname(outputFilePath);
  await fs.promises.mkdir(outputDirectory, { recursive: true });

  await fs.promises.writeFile(outputFilePath, formattedResult);
}
